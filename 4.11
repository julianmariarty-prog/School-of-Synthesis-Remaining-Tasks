module sqrt_formula_distributor
# (
    parameter formula = 1,
              impl    = 1
)
(
    input         clk,
    input         rst,

    input         arg_vld,
    input  [31:0] a,
    input  [31:0] b,
    input  [31:0] c,

    output        res_vld,
    output [31:0] res
);

    localparam NUM_UNITS = 5;
    localparam LATENCY = 50;
    
    logic [NUM_UNITS-1:0] unit_busy;
    logic [NUM_UNITS-1:0] unit_res_vld;
    logic [31:0] unit_res [NUM_UNITS-1:0];
    logic res_vld_reg;
    logic [31:0] res_reg;
    logic stall; 
    logic free_unit_found;
    logic [$clog2(NUM_UNITS)-1:0] free_unit;
    
    always_comb begin
        free_unit_found = 1'b0;
        free_unit = '0;
        for (int i = 0; i < NUM_UNITS; i++) begin
            if (!unit_busy[i]) begin
                free_unit_found = 1'b1;
                free_unit = i;
                break;
            end
        end
    end
    
    assign stall = arg_vld && !free_unit_found;
    
    generate
        if (formula == 1) begin
            for (genvar i = 0; i < NUM_UNITS; i++) begin
                if (impl == 1) begin
                    formula_1_impl_1_top unit_i (
                        .clk(clk), .rst(rst),
                        .arg_vld(arg_vld && free_unit_found && (free_unit == i)),
                        .a(a), .b(b), .c(c),
                        .res_vld(unit_res_vld[i]),
                        .res(unit_res[i])
                    );
                end else begin
                    formula_1_impl_2_top unit_i (
                        .clk(clk), .rst(rst),
                        .arg_vld(arg_vld && free_unit_found && (free_unit == i)),
                        .a(a), .b(b), .c(c),
                        .res_vld(unit_res_vld[i]),
                        .res(unit_res[i])
                    );
                end
            end
        end else begin // formula == 2
            for (genvar i = 0; i < NUM_UNITS; i++) begin
                formula_2_top unit_i (
                    .clk(clk), .rst(rst),
                    .arg_vld(arg_vld && free_unit_found && (free_unit == i)),
                    .a(a), .b(b), .c(c),
                    .res_vld(unit_res_vld[i]),
                    .res(unit_res[i])
                );
            end
        end
    endgenerate

    always_ff @(posedge clk or posedge rst) begin
        if (rst) begin
            unit_busy <= '0;
        end else begin
            for (int i = 0; i < NUM_UNITS; i++) begin
                if (arg_vld && free_unit_found && (free_unit == i)) begin
                    unit_busy[i] <= 1'b1;
                end
                if (unit_res_vld[i]) begin
                    unit_busy[i] <= 1'b0;
                end
            end
        end
    end
    

    always_ff @(posedge clk or posedge rst) begin
        if (rst) begin
            res_vld_reg <= 1'b0;
            res_reg <= '0;
        end else begin
            res_vld_reg <= |unit_res_vld; 
            for (int i = 0; i < NUM_UNITS; i++) begin
                if (unit_res_vld[i]) begin
                    res_reg <= unit_res[i];
                end
            end
        end
    end
    
    assign res_vld = res_vld_reg;
    assign res = res_reg;

endmodule

    // Task:
    //
    // Implement a module that will calculate formula 1 or formula 2
    // based on the parameter values. The module must be pipelined.
    // It should be able to accept new triple of arguments a, b, c arriving
    // at every clock cycle.
    //
    // The idea of the task is to implement hardware task distributor,
    // that will accept triplet of the arguments and assign the task
    // of the calculation formula 1 or formula 2 with these arguments
    // to the free FSM-based internal module.
    //
    // The first step to solve the task is to fill 03_04 and 03_05 files.
    //
    // Note 1:
    // Latency of the module "formula_1_isqrt" should be clarified from the corresponding waveform
    // or simply assumed to be equal 50 clock cycles.
    //
    // Note 2:
    // The task assumes idealized distributor (with 50 internal computational blocks),
    // because in practice engineers rarely use more than 10 modules at ones.
    // Usually people use 3-5 blocks and utilize stall in case of high load.
    //
    // Hint:
    // Instantiate sufficient number of "formula_1_impl_1_top", "formula_1_impl_2_top",
    // or "formula_2_top" modules to achieve desired performance.

