module put_in_order
# (
    parameter width    = 16,
              n_inputs = 4
)
(
    input                       clk,
    input                       rst,

    input  [ n_inputs - 1 : 0 ] up_vlds,
    input  [ n_inputs - 1 : 0 ]
           [ width    - 1 : 0 ] up_data,

    output                      down_vld,
    output [ width   - 1 : 0 ]  down_data
);

    logic [n_inputs-1:0] pending;
    logic [width-1:0] data_buffer [n_inputs-1:0];
    logic [$clog2(n_inputs)-1:0] current_ptr;
    logic down_vld_reg;
    logic [width-1:0] down_data_reg;
    logic [n_inputs-1:0] pending_rotated;

    always_ff @(posedge clk or posedge rst) begin
        if (rst) begin
            pending <= '0;
            for (int i = 0; i < n_inputs; i++) begin
                data_buffer[i] <= '0;
            end
        end else begin
            for (int i = 0; i < n_inputs; i++) begin
                if (up_vlds[i]) begin
                    pending[i] <= 1'b1;
                    data_buffer[i] <= up_data[i];
                end
            end
            if (down_vld_reg) begin
                pending[current_ptr] <= 1'b0;
            end
        end
    end

    assign pending_rotated = (pending >> current_ptr) | (pending << (n_inputs - current_ptr));

    always_ff @(posedge clk or posedge rst) begin
        if (rst) begin
            current_ptr <= '0;
            down_vld_reg <= 1'b0;
            down_data_reg <= '0;
        end else begin
            down_vld_reg <= 1'b0;

            for (int i = 0; i < n_inputs; i++) begin
                if (pending_rotated[i]) begin
                    down_vld_reg <= 1'b1;
                    down_data_reg <= data_buffer[(current_ptr + i) % n_inputs];
                    current_ptr <= (current_ptr + i + 1) % n_inputs;
                    break;
                end
            end
        end
    end

    assign down_vld = down_vld_reg;
    assign down_data = down_data_reg;

endmodule

    // Task:
    //
    // Implement a module that accepts many outputs of the computational blocks
    // and outputs them one by one in order. Input signals "up_vlds" and "up_data"
    // are coming from an array of non-pipelined computational blocks.
    // These external computational blocks have a variable latency.
    //
    // The order of incoming "up_vlds" is not determent, and the task is to
    // output "down_vld" and corresponding data in a round-robin manner,
    // one after another, in order.
    //
    // Comment:
    // The idea of the block is kinda similar to the "parallel_to_serial" block
    // from Homework 2, but here block should also preserve the output order.


